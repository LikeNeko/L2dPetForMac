diff --git a/node_modules/imap/deps/encoding/encoding.js b/node_modules/imap/deps/encoding/encoding.js
index 61b7bb0..13fafbd 100644
--- a/node_modules/imap/deps/encoding/encoding.js
+++ b/node_modules/imap/deps/encoding/encoding.js
@@ -2244,7 +2244,7 @@ TextEncoder.prototype = {
       } while (last_byte !== EOF_byte);
       this._encoder = null;
     }
-    return new Buffer(bytes);
+    return Buffer.alloc(bytes);
   }
 };
 
diff --git a/node_modules/imap/lib/Connection.js b/node_modules/imap/lib/Connection.js
index 619862f..5ce762e 100644
--- a/node_modules/imap/lib/Connection.js
+++ b/node_modules/imap/lib/Connection.js
@@ -240,7 +240,7 @@ Connection.prototype.connect = function() {
       // now idling
       self._idle.started = Date.now();
     } else if (/^AUTHENTICATE XOAUTH/.test(self._curReq.fullcmd)) {
-      self._curReq.oauthError = new Buffer(info.text, 'base64').toString('utf8');
+      self._curReq.oauthError = Buffer.alloc(info.text, 'base64').toString('utf8');
       self.debug && self.debug('=> ' + inspect(CRLF));
       self._sock.write(CRLF);
     } else if (type === 'APPEND') {
@@ -1847,7 +1847,7 @@ function buildString(str) {
     str = ''+str;
 
   if (hasNonASCII(str)) {
-    var buf = new Buffer(str, 'utf8');
+    var buf = Buffer.alloc(str, 'utf8');
     return '{' + buf.length + '}\r\n' + buf.toString('binary');
   } else
     return '"' + escape(str) + '"';
diff --git a/node_modules/imap/lib/Parser.js b/node_modules/imap/lib/Parser.js
index 16297d3..df36a8f 100644
--- a/node_modules/imap/lib/Parser.js
+++ b/node_modules/imap/lib/Parser.js
@@ -440,7 +440,7 @@ function parseFetch(text, literals, seqno) {
       val = parseBodyStructure(val);
     else if (m = RE_BODYINLINEKEY.exec(list[i])) {
       // a body was sent as a non-literal
-      val = new Buffer(''+val);
+      val = Buffer.alloc(''+val);
       body = new ReadableStream();
       body._readableState.sync = false;
       body._read = EMPTY_READCB;
@@ -764,7 +764,7 @@ function decodeBytes(buf, encoding, offset, mlen, pendoffset, state, nextBuf) {
       if (state.encoding === encoding && state.consecutive) {
         // concatenate buffer + current bytes in hopes of finally having
         // something that's decodable
-        var newbuf = new Buffer(state.buffer.length + buf.length);
+        var newbuf = Buffer.alloc(state.buffer.length + buf.length);
         state.buffer.copy(newbuf, 0);
         buf.copy(newbuf, state.buffer.length);
         buf = newbuf;
@@ -795,7 +795,7 @@ function decodeBytes(buf, encoding, offset, mlen, pendoffset, state, nextBuf) {
       // try to decode a lookahead buffer (current buffer + next buffer)
       // and see if it starts with the decoded value of the current buffer.
       // if not, the current buffer is partial
-      var lookahead, lookaheadBuf = new Buffer(buf.length + nextBuf.length);
+      var lookahead, lookaheadBuf = Buffer.alloc(buf.length + nextBuf.length);
       buf.copy(lookaheadBuf);
       nextBuf.copy(lookaheadBuf, buf.length);
       try {
@@ -924,17 +924,17 @@ function decodeWords(str, state) {
     state.consecutive = m.consecutive;
     if (m.encoding === 'q') {
       // q-encoding, similar to quoted-printable
-      bytes = new Buffer(m.chunk.replace(RE_QENC, qEncReplacer), 'binary');
+      bytes = Buffer.alloc(m.chunk.replace(RE_QENC, qEncReplacer), 'binary');
       next = undefined;
     } else {
       // base64
-      bytes = m.buf || new Buffer(m.chunk, 'base64');
+      bytes = m.buf || Buffer.alloc(m.chunk, 'base64');
       next = replaces[i + 1];
       if (next && next.consecutive && next.encoding === m.encoding
         && next.charset === m.charset) {
         // we use the next base64 chunk, if any, to determine the integrity
         // of the current chunk
-        next.buf = new Buffer(next.chunk, 'base64');
+        next.buf = Buffer.alloc(next.chunk, 'base64');
       }
     }
     decodeBytes(bytes, m.charset, m.index, m.length, m.pendoffset, state,
